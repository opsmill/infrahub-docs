---
title: Check
---

Checks are user defined logic, stored in an [external repository linked to Infrahub](../topics/repository.mdx), that are run as part of a [proposed change](../topics/proposed-change.mdx). It allows a user to perform any kind of data validation logic during a proposed change. If a check does not complete successfully, then the proposed change cannot be merged.

Some examples:

- name validation against a naming convention for all infrastructure components in the database
- validate that we always have a redundant WAN circuit in operational state for every site
- validate that all internet facing interfaces have an inbound access-list associated

## High level design

A check is composed of 2 main components:

- A GraphQL Query that will define the input data
- A check logic in the Python language that will validate the data

![High level design](../media/topics/checks.excalidraw.svg)

## Targeted checks

Targeted checks are exactly the same as a check, the main difference is that they target a specific [group](./groups.mdx) of nodes in Infrahub. The check will then only be executed against the nodes in that group.

This approach leverages groups to enable scalable validation - instead of running checks against all objects of a type, you can focus validation on logically related objects. Groups provide flexible targeting that can be updated independently of the check definitions.

An example of such scenario could be that you want to validate that all devices for which we generate an OpenConfig artifact, have the NETCONF service enabled. By targeting the group used for artifact generation, the check automatically stays synchronized with the artifact scope.

See [organizing objects with groups](../guides/groups.mdx) for details on creating target groups for your checks.
